"use server";

import OpenAI from "openai";
import getGitHubImageUrl from "@/lib/getGitHubImageUrl";
import { getOrCreateThreadId } from "@/app/actions/getOrCreateThreadId";
import { db } from "@/db";
import { appConfig } from "@/db/schema";
import { eq } from "drizzle-orm";

type FunctionParams = {
  sessionId: string;
  imageTitle: string;
  imageFilename: string;
  misleadingFeature: string;
  initialIncorrectReasoning: string;
  featureIdentification: string;
  reasoningRevision: string;
  phase: "featureIdentification" | "reasoningRevision";
};

type EvaluationResult = {
  assistantFeedback: string;
  chatbotReasoning: string;
};

export default async function getEvaluationAndUpdatedReasoning(
  params: FunctionParams
): Promise<EvaluationResult> {
  try {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) throw new Error("OpenAI API key not found");

    // ✅ Fetch assistant ID and model from DB
    const [assistantRow, modelRow] = await Promise.all([
      db.query.appConfig.findFirst({
        where: eq(appConfig.configKey, "OPENAI_ASSISTANT_ID"),
      }),
      db.query.appConfig.findFirst({
        where: eq(appConfig.configKey, "OPENAI_MODEL"),
      }),
    ]);

    const assistantId = assistantRow?.configValue;
    const model = modelRow?.configValue || "gpt-4o";

    if (!assistantId) {
      throw new Error("Assistant ID not found in app_config table");
    }

    const openai = new OpenAI({ apiKey });

    /*const instructions = `
        You are an AI tutor that helps users critically evaluate misleading data visualizations.
        First, you and the user will be given the flawed reasoning about the given misleading data visualization.
        Then, the user will give you the correction about this flawed reasoning.
        
        After receiving the user's correction, you will give a one sentence feedback on the user's correction. 
        Only if when the users' correction is correct or partially capture the misleading feature, you will revise the flawed reasoning according to the user's correction.
        However, if the user's correction is not correct or inappropriate (out of context), then only give a short one sentence encouraging message (the second role).
      `.trim();

    const current = await openai.beta.assistants.retrieve(assistantId);

    if (current.instructions !== instructions || current.model !== model) {
      await openai.beta.assistants.update(assistantId, {
        instructions,
        model,
      });
    }*/

    const threadId = await getOrCreateThreadId({
      sessionId: params.sessionId,
      imageFilename: params.imageFilename,
    });

    console.log("phase:", params.phase)
    if (params.phase === "featureIdentification") {
      // Step 1: Show flawed reasoning and image
      await openai.beta.threads.messages.create(threadId, {
        role: "user",
        content: [
          { type: "text", text: `This is the flawed reasoning: ${params.initialIncorrectReasoning} generated by a misled person who is deceived by ${params.misleadingFeature} embedded in ${params.imageTitle}. Please help students to identify this ${params.misleadingFeature} within this visualization  ${params.imageTitle}.` },
          { type: "image_url", image_url: { url: getGitHubImageUrl(params.imageFilename) } },
        ],
      });

      const run = await openai.beta.threads.runs.create(threadId, {
        assistant_id: assistantId,
      });
      
      let runStatus;
      do {
        runStatus = await openai.beta.threads.runs.retrieve(threadId, run.id);
        await new Promise((res) => setTimeout(res, 1000));
      } while (runStatus.status !== "completed");

      console.log("featureIdentification:", params.featureIdentification);
      // Step 2: Student's feature identification
      await openai.beta.threads.messages.create(threadId, {
        role: "user",
        content: [
          { type: "text", text: params.featureIdentification || "" },
        ],
      });

      // Step 3: Evaluate feature identification
      const featureEvalPrompt = `
        Evaluate the user's feature identification: "${params.featureIdentification}".
        - If correct or partially correct (related to ${params.misleadingFeature}), start your reply with "Correct:".
        - If wrong or vague, start your reply with "Incorrect:".
        - Give brief feedback but do not explicitly reveal the misleading feature.
      `.trim();

      await openai.beta.threads.messages.create(threadId, {
        role: "user",
        content: [
          { type: "text", text: featureEvalPrompt },
        ],
      });

    } else if (params.phase === "reasoningRevision") {
      // Step 4: Student suggests reasoning revision
      await openai.beta.threads.messages.create(threadId, {
        role: "user",
        content: [
          { type: "text", text: params.reasoningRevision || "" },
        ],
      });

      // Step 5: Evaluate reasoning revision
      const revisionEvalPrompt = `
        The student suggested how to revise the flawed reasoning: "${params.reasoningRevision}".
        Please create a revised flawed reasoning starting with "Revised Flawed Reasoning:", reflecting the student's suggestion.
      `.trim();

      await openai.beta.threads.messages.create(threadId, {
        role: "user",
        content: [
          { type: "text", text: revisionEvalPrompt },
        ],
      });
    }

    const run = await openai.beta.threads.runs.create(threadId, {
      assistant_id: assistantId,
    });

    let runStatus;
    do {
      runStatus = await openai.beta.threads.runs.retrieve(threadId, run.id);
      await new Promise((res) => setTimeout(res, 1000));
    } while (runStatus.status !== "completed");

    const messages = await openai.beta.threads.messages.list(threadId);
    const firstContent = messages.data[0].content[0];
    const fullText = "text" in firstContent ? firstContent.text.value : "";
    
    let assistantFeedback = "";
    let chatbotReasoning = "";
    
    if (params.phase === "featureIdentification") {
      // 학생이 misleading feature 찾는 phase일 때
      assistantFeedback = fullText.trim(); // 답변 전체를 feedback으로
      chatbotReasoning = ""; // 아직 reasoning 고치는 단계 아님
    } else if (params.phase === "reasoningRevision") {
      // reasoning revision phase일 때
      const [feedbackPart, reasoningPart] = fullText.split("Revised Flawed Reasoning:");
      assistantFeedback = feedbackPart?.trim() || "No feedback received.";
      chatbotReasoning = reasoningPart
        ? "Revised Flawed Reasoning: " + reasoningPart.trim()
        : "No revised reasoning.";
    }
    return {
      assistantFeedback,
      chatbotReasoning,
    };
    
  } catch (error) {
    console.error("❌ OpenAI API Error:", error);
    throw error;
  }
}
